package com.seiya.commons.collections;

public class StudyNotes {

    /**
     * transient关键字能实现什么(用途)?
     *
     * 当对象被序列化时（写入字节序列到目标文件）时，transient阻止实例中那些用此关键字声明的变量持久化；
     * 当对象被反序列化时（从源文件读取字节序列进行重构），这样的实例变量值不会被持久化和恢复。
     * 例如，当反序列化对象——数据流（例如，文件）可能不存在时，原因是你的对象中存在类型为
     * java.io.InputStream的变量，序列化时这些变量引用的输入流无法被打开
     */

    /**
     * Hash是散列的意思，就是把任意长度的输入，通过散列算法变换成固定长度的输出，该输出就是散列值
     * 一个对象的哈希码允许算法和数据结构将对象放入隔间，就象打印机类型案件中的字母类型。打印机将
     * 所有的“A”类型放到一个房间，它寻找这个“A”的时候就只需要在这个房间进行寻找。这种简单的系统让
     * 他在未排序的抽屉中寻找类型的时候更快。这也是基于哈希的集合的想法，例如 HashMap 和 HashSet。
     *
     * 1、如果散列表中存在和散列原始输入K相等的记录，那么K必定在f(K)的存储位置上
     *
     * 2、不同关键字经过散列算法变换后可能得到同一个散列地址，这种现象称为碰撞
     *
     * 3、如果两个Hash值不同（前提是同一Hash算法），那么这两个Hash值对应的原始输入必定不同
     */

    // 官方文档的定义
    //1、HashCode的存在主要是为了查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的
    //2、如果两个对象equals相等，那么这两个对象的HashCode一定也相同
    //3、如果对象的equals方法被重写，那么对象的HashCode方法也尽量重写
    //4、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置，如Hashtable，他们“存放在同一个篮子里
    //
    // 注：如果两个不同对象的hashCode相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的hashCode()方法，能加快哈希表的操作。
    // 如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null），要避免这种问题，只需要牢记一条：要同时复写equals方法和hashCode方法，而不要只写其中一个。
    /**
     * 百度百科
     *
     * hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值 详细了解请 参考 [1]
     * public int hashCode()返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。
     */


    /**
     * 如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。
     * 如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。
     * 要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。
     * 尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程
     */


    /**
     *   关于HashMap中的IndexOf方法原来一直没有想通为什么用&,并且和length-1做运算，今天琢磨了一下
     *
     *   static int indexFor(int h, int length) {
     *         return h & (length-1);
     *   }
     *
     * 前提   首先大家知道普通的Hash打散的算法都是mod表的长度，比如h%length,但是HashMap却用的是位运算
     * 分析   HashMap的初始大小和扩容都是以2的次方来进行的，换句话说length-1换成二进制永远是全部为1，比如容量为16，
     *          则length-1为1111，大家知道位运算的规则是两个1才得1，遇0的0，也就是说length-1中的某一位为1，则对应位
     *          置的计算结果才取决于h中的对应位置（h中对应位取0,对应位结果为0，h对应位取1，对应位结果为1。这样就有两个
     *          结果），但是如果length-1中某一位为0，则不论h中对应位的数字为几，对应位结果都是0，这样就让两个h取到同一
     *          个结果，这就是hash冲突了，恰恰length-1又是全部为1的数，所以结果自然就将hash冲突最小化了
     * 对比 仔细观察可以发现其实老方法h%length与h&（length-1）得到的结果其实是一个值，但是为什么hashmap中要用后者呢
     *          1.length（2的整数次幂）的特殊性导致了length-1的特殊性（二进制全为1）
     *          2.位运算快于十进制运算，hashmap扩容也是按位扩容，所以相比较就选择了后者
     */

    /**
     * 解决Hash的的冲突的函数，解决Hash的冲突有以下几种方法：

     *  (1)、开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）
     *  (2)、再哈希法
     *  (3)、链地址法
     *  (4)、建立一 公共溢出区
     *
     *  而HashMap采用的是链地址法
     */


}
